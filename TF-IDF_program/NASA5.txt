GuSTO: Guaranteed Sequential Trajectory Optimization
via Sequential Convex Programming
Riccardo Bonalli, Abhishek Cauligi, Andrew Bylard, Marco Pavone
Abstract— Sequential Convex Programming (SCP) has recently seen a surge of interest as a tool for trajectory optimization. However, most available methods lack rigorous
performance guarantees and they are often tailored to specific
optimal control setups. In this paper, we present GuSTO
(Guaranteed Sequential Trajectory Optimization), an algorithmic framework to solve trajectory optimization problems for
control-affine systems with drift. GuSTO generalizes earlier
SCP-based methods for trajectory optimization (by addressing,
for example, goal-set constraints and problems with either
fixed or free final time) and enjoys theoretical convergence
guarantees in terms of convergence to, at least, a stationary
point. The theoretical analysis is further leveraged to devise
an accelerated implementation of GuSTO, which originally
infuses ideas from indirect optimal control into an SCP context.
Numerical experiments on a variety of trajectory optimization
setups show that GuSTO generally outperforms current stateof-the-art approaches in terms of success rates, solution quality,
and computation times.
I. INTRODUCTION
Trajectory optimization algorithms play a key role in
robot motion planning, either being applied directly to solve
planning problems or being used to refine coarse trajectories
generated by other methods. A wide variety of algorithmic
frameworks have been proposed [1]–[8], and though they
have had success on a broad class of robotic systems, a large
gap remains in establishing practical guidelines for applying
trajectory optimization to new systems and problem setups,
placing guarantees on their behavior, and fully exploiting
optimal control theory to improve performance.
In particular, additional work is required to achieve more
general, well-analyzed frameworks for trajectory optimization algorithms which meet the following key desiderata:
1) High computational speed: Even on high-dimensional
systems having complex dynamics and constraints, trajectory optimization algorithms should converge rapidly,
allowing quick responses to commands and rapid replanning in uncertain or changing environments.
2) Theoretical guarantees: A reliable framework hinges on
strong theoretical guarantees. Specifically, trajectory optimization algorithms should (i) guarantee initializationindependent convergence to, at least, a stationary point,
(ii) ensure hard enforcement of dynamical constraints,
especially as many robotic systems are nonholonomic,
and (iii) provide that these guarantees are discretizationindependent, since some robotic systems may call for
specific numerical schemes.
3) Generality: Trajectory optimization frameworks should
be broadly applicable to different robot motion planning
problems, including involving complex robotic systems
R. Bonalli, A. Cauligi, A. Bylard, and M. Pavone are with the Department
of Aeronautics and Astronautics, Stanford University, Stanford, CA 94305.
{rbonalli, acauligi, bylard, pavone} @stanford.edu.
This work was supported in part by NASA under the Space Technology Research Program, NASA Space Technology Research Fellowship
Grants NNX16AM78H and NNX15AP67H, Early Career Faculty Grant
NNX12AQ43G and Early Stage Innovations Grant NNX16AD19G, and by
KACST.
Fig. 1: GuSTO used to generate a dynamically-feasible, collisionfree trajectory for the Astrobee free-flying spacecraft robot using a
simple straight-line initialization [9].
(e.g., nonconvex, nonholonomic dynamics, drift systems, etc.), flexible problem setups (e.g., free final time,
goal sets, etc.), and diverse initialization strategies.
Related work: The trajectory optimization spectrum can be
divided into global search methods and local methods. Global
search methods include motion planning techniques, such
as asymptotically optimal sampling-based motion planning
(SBP) algorithms (e.g., RRT∗
, PRM∗
, and FMT∗
) [10]–[12].
Though these require no initialization, they scale poorly to
high-dimensional systems with kinodynamic constraints. For
such systems, SBP techniques require enormous computational time and are thus instead used in practice to initialize
other trajectory optimization algorithms.
Local methods include indirect methods, in particular
including shooting methods [8]. Built on an efficient coupling
of necessary conditions of optimality, such as the Pontryagin
Maximum Principle [13], and Newton’s methods, these have
the fastest convergence rate, but they are highly sensitive
to initialization and are thus difficult to apply to different
tasks. Another class of efficient local procedures is direct
methods. One of these, which is the focus of this paper, is
sequential convex programming (SCP), a framework which
has been quite successful in the robotics community [1]–
[3], [14]–[16]. SCP successively convexifies the costs and
constraints of a nonconvex optimal control problem, seeking
a solution to the original problem through a series of convex
problems [17], [18]. Examples include TrajOpt [1], Liu, et
al. [2], and Mao, et al. [3]. However, these suffer a number
of deficiencies, as summarized in Table I. For example,
TrajOpt provides high speed and broad applicability to
robotic systems, but the penalization of dynamical constraints
and the missing development of convergence guarantees preclude exact feasibility and numerical robustness, respectively.
Similarly, [2] only holds for a particular time-discretization,
and though the approach in [3] is discretization-indepedent,
it cannot ensure hard enforcement of dynamics. Further, its
arXiv:1903.00155v1 [math.OC] 1 Mar 2019
constraints
of dynamics
enforcement
Hard
guarantees
convergence
Continuous-time
discretization
of time
Independent
final time
Free
constraint
Goal-set
shooting method
can warm-start
dual solution that
Provides
Optimal SBP • • • • •
TrajOpt [1]
Liu, et al. [2] • • •
Mao, et al. [3] • •
CHOMP [6] •
STOMP [7]
This Work • • • • • •
TABLE I: Comparison with existing trajectory optimization schemes.
convergence analysis relies on complex Lagrange multipliers
from which it is difficult to extract numerically useful
information, a key capability exploited in part in our work.
Finally, in most of these works, extensions to free final time
and goal-set constraints are not addressed.
One last family of widespread procedures in trajectory
optimization is variational methods. These include deterministic covariant approaches such as CHOMP [6] and probabilistic gradient descent approaches such as STOMP [7].
Similar to SCP, these do not necessarily require high-quality
initializations, but theoretical guarantees are not easy to
provide. Indeed, CHOMP does not incorporate the dynamical
evolution of a system, while STOMP can only account
for constraints through direct penalization, preventing hard
enforcement of dynamics. Thus, convergence guarantees are
not provided in both approaches.
Statement of Contributions: To begin to fill these gaps,
our main contributions in this paper are as follows: First,
we introduce Guaranteed Sequential Trajectory Optimization
(GuSTO), an SCP-based algorithmic framework for trajectory optimization. More precisely, we provide a generalized
continuous-time SCP scheme applied to drift control-affine
nonlinear dynamical systems subject to control and state
constraints (including collision-avoidance) and goal-set constraints, guaranteeing dynamic feasibility with either fixed or
free final time. Second, we provide a theoretical analysis for
this framework, proving that that the limiting solution of our
continuous-time scheme is a stationary point in the sense of
the Pontryagin Maximum Principle [13]. This generalizes
the work in [3] for control-affine systems and introduces
stronger theoretical guarantees than the current state-of-theart. Moreover, the generality of our framework enables these
guarantees to be independent of the chosen time discretization scheme and the method used to find a solution at each
SCP iteration. Indeed, the framework is broadly applicable
to many different robot motion planning and trajectory optimization problems, which then enjoy the same guarantees.
This analysis is further leveraged to accelerate convergence
by initializing shooting methods with the dual solutions of
SCP iterations. Third, we provide practical guidelines based
on our analysis, including proper handling of constraints
and initialization strategies. Moreover, we demonstrate the
framework through numerical and hardware experiments,
provide comparison to other approaches, and provide a Julia
library for our trajectory optimization framework.
To the best of our knowledge, our framework uniquely
meets all three aforementioned desiderata, rapidly providing theoretically desirable trajectories for a broad range
of robotic systems and problem setups (see Table I for a
comparison to some existing approaches).
II. PROBLEM FORMULATION AND OVERVIEW OF SCP
We begin by reviewing the optimal control problem of
interest in Section II-A and then provide an overview of an
SCP framework for trajectory optimization in II-B.
A. Trajectory Optimization as an Optimal Control Problem
Given a fixed initial point x¯0 ∈ R
n and a final goal set
Mf ⊆ R
n, for every final time tf > 0, we model our
dynamics as a drift control-affine system in R
n of the form



x˙(t) = f(x(t), u(t)) = f0(x(t)) +Xm
i=1
u
i
(t)fi(x(t))
x(0) = ¯x0 , x(tf ) ∈ Mf s.t. dist(¯x0, Mf ) > 0
(1)
where fi
: R
n → R
n, i = 0, . . . , m are C
1 vector fields, and
dist(x, A) = infy∈A kx − yk2.
In this context, we design trajectory optimization as an
optimal control problem with penalized state constraints.
More specifically, we consider the Optimal Control Problem
(OCP) consisting of minimizing the integral cost
J(tf , x, u) = Z tf
0
f
0
(x(t), u(t)) dt =
Z tf
0

ku(t)k
2
R + u(t) · f
0
(x(t)) + g(x(t))
dt
(2)
under dynamics (1), among all the controls u ∈
L∞([0, tf ], R
m) satisfying u(t) ∈ U almost everywhere in
[0, tf ]. Here, f
0
: R
n → R
m, g : R
n → R are C
1
, k · kR
represents the norm that is given by a constant positivedefinite matrix R ∈ R
m×m, and U ⊆ R
m provides control
constraints. The final time tf may be free or fixed, and
hard enforcement of dynamical and goal-set constraints are
naturally imposed by (1). Function g = ¯g1 + ωg¯2 sums
up the contributions of the state-depending terms g¯1 of
the cost unrelated to constraints and of the sum of state
constraint violations g¯2 (e.g., collision-avoidance violation),
where ω ≥ 1 is a penalization weight. We stress that penalizing state constraints is fundamental to obtaining theoretical
guarantees in the sense of the classical Pontryagin Maximum
Principle [13] (see Theorem III.1), stronger than standard
Lagrange multiplier rules. However, in Sec. III, we provide
an algorithm under this formulation which can still enforce
hard state constraints up to some chosen tolerance ε ≥ 0.
B. Sequential Convex Programming
We proceed by applying sequential convex programming
to solve our optimal control problem. Under the assumption
that U is convex, SCP consists of iteratively linearizing the
nonlinear contributions of (OCP) around local solutions 
thus recursively defining a sequence of simplified problems.
More specifically, for a given t
0
f > 0, assume we have
some continuous curve x0 : [0, t0
f
] → R
n and some control
law u0 : [0, t0
f
] → R
m, continuously extended in the
interval (0, +∞). Defined inductively, at iteration k + 1, the
Linearized Optimal Control Problem (LOCP)k+1 consists of
minimizing the new integral cost
Jk+1(tf , x, u) = Z tf
0
f
0
k+1(t, x(t), u(t)) dt =
Z tf
0

ku(t)k
2
R + hk

kx(t) − xk(t)k
2 − ∆k
 dt +
Z tf
0
u(t) ·

f
0
(xk(t)) + ∂f0
∂x
(xk(t)) · (x(t) − xk(t))
dt +
Z tf
0

gk(xk(t)) + ∂gk
∂x
(xk(t)) · (x(t) − xk(t))
dt
(3)
where gk = ¯g1 + ωkg¯2 and hk(s) is any smooth approximation of ωk max{0, s} [19, Ch. 10], under the new dynamics



x˙ (t) = fk+1(t, x(t), u(t)) =

f0(xk(t)) +Xm
i=1
u
i
(t)fi(xk(t))!
+

∂f0
∂x
(xk(t)) +Xm
i=1
u
i
k
(t)
∂fi
∂x
(xk(t))!
· (x(t) − xk(t))
x(0) = ¯x0 , x(tf ) ∈ Mf
(4)
coming from the linearization of nonlinear vector fields,
among all controls u ∈ L∞([0, tf ], R
m) satisfying u(t) ∈ U
almost everywhere in [0, tf ], where (t
k
f
, xk, uk) is a solution
for the linearized problem at the previous iteration, i.e.
(LOCP)k, continuously extended in the interval (0, +∞).
As a result of the functions hk ∈ C∞, we can provide trustregion-type constraints on state trajectories using uniformly
bounded scalars 0 ≤ ∆k ≤ ∆0 and weights 1 ≤ ω0 ≤ ωk ≤
ωmax (no such bounds are considered on controls because
u appears linearly), which at the same time penalize state
constraints violations g¯2. Here, the user may make vary ∆k
and ωk at each iteration — these are used merely to ease
the search for a solution of (LOCP)k+1. Problem (LOCP)1
is linearized around an initializing couple (x0, u0), and this
initialization curve should be as close as possible to a feasible
or even optimal curve for (LOCP)1, although we do not
require that (x0, u0) is feasible for (OCP).
The sequence of problems (LOCP)k is correctly defined
if, for each iteration k ≥ 1, an optimal solution for (LOCP)k
exists. For this, we consider the following assumptions:
(A1) The set U is compact and convex, while the set Mf is a
compact submanifold (either with or without boundary).
(A2) Mappings f
0
, g, vector fields fi
, i = 0, . . . , m and
their differentials have compact supports.
(A3) At every iteration k ≥ 1, problem (LOCP)k is feasible.
Moreover, for free final time problems, there exists a
constant b > 0 such that, every feasible tuple (tf , x, u)
for (LOCP)k satisfies tf ≤ b, for every iteration k ≥ 1.
Under these assumptions, classical existence Filippov-type
arguments [20], [21] show that at each iteration k ≥ 1, the
problem (LOCP)k has at least one optimal solution. Here,
some comments are in order. Assumption (A2) is not limiting
and can be easily satisfied by multiplying all noncompliant
maps by smooth cut-off functions having supports contained
in the working space. Moreover, it is standard in control
theory to assume time-bounded strategies, and we can satisfy
(A3) by simply considering the notion of virtual control [3].
Indeed, we stress the fact that most trajectory optimization
applications effortlessly satisfy Assumptions (A1)-(A3).
III. GUSTO: ALGORITHM OVERVIEW
AND THEORETICAL ANALYSIS
In this section, we present the algorithmic details for
GuSTO in III-A and discuss its theoretical convergence
guarantees to a stationary point in III-B.
A. Generalized SCP Algorithm
SCP aims to solve (OCP) by iteratively seeking solutions to (LOCP)k. For this process, the progression through
iterations must be designed carefully in order to achieve
numerical efficiency and fast computation. Supported by
classical approaches [22] and more recent results in SCP
for robot trajectory optimization [1], [3], we propose a new
general SCP scheme, named GuSTO (Guaranteed Sequential
Trajectory Optimization), to solve (OCP), as reported in
Algorithm 1. Our main novelties are: 1) a time-continuous,
broadly applicable setup ensuring convergence to a stationary
point in the sense of the Pontryagin Maximum Principle
[13] (see Corollary III.1), 2) hard enforcement of dynamical
constraints and ease in considering free final time and goalset problems, 3) a refined trust-region radius adaptation step
based on a new model accuracy ratio which provides a
definition of relative error between iterations and prevents the
algorithm from becoming stuck in a cycle within its loops, 4)
a theoretically justified stopping criterion based on closeness
between iterated solutions.
Algorithm 1: GuSTO
Input : Trajectory x0 and control u0 defined in (0, ∞).
Output: Solution (xk, uk) for (LOCP)k at iteration k.
Data : State constraints data ∆0 > 0, ω0 ≥ 1, ε ≥ 0;
Trust region scaling parameters 0 < βfail < 1,
βsucc > 1, 0 < ρ0 < ρ1 < 1, γfail > 1.
1 begin
2 k = 0
3 while (t
k+1
f
, xk+1, uk+1) 6= (t
k
f
, xk, uk) and
ωk+1 ≤ ωmax do
4 Solve (LOCP)k+1 for (t
k+1
f
, xk+1, uk+1)
5 if kxk+1 − xkk
2
(·) ≤ ∆k then
6 Calculate model accuracy ratio ρ(k)
in (5)
7 if ρ(k) > ρ1 then
8 Reject solution (t
k+1
f
, xk+1, uk+1)
9 ∆k+1 ← βfail∆k , ωk+1 ← ωk
10 else
11 Accept solution (t
k+1
f
, xk+1, uk+1)
12 ∆k+1 ←

min{βsucc∆k, ∆0} ρ(k) < ρ0
∆k ρ(k) ≥ ρ0
13 ωk+1 ←

ω0 g¯2(xk+1(·)) ≤ ε
γfailωk g¯2(xk+1(·)) > ε
14 else
15 Reject solution (t
k+1
f
, xk+1, uk+1)
16 ∆k+1 ← ∆k , ωk+1 ← γfailωk
17 k ← k + 1
18 return (t
k
f
, xk, u  
Once (LOCP)k+1 is solved at some iteration k (line 4), we
first check whether hard trust-region constraints are satisfied.
In the positive case, we evaluate the ratio
ρ(k) = Nk/Dk =

|J(t
k+1
f
, xk+1, uk+1) − Jk+1(t
k+1
f
, xk+1, uk+1)|+
Z t
k+1
f
0
kf(xk+1(t), uk+1(t)) − fk+1(t, xk+1(t), uk+1(t))k dt
.

|Jk+1(t
k+1
f
, xk+1, uk+1)| +
Z t
k+1
f
0
kfk+1(t, xk+1(t), uk+1(t))k dt
!
(5)
which represents the relative error between the original
cost/dynamics and their convexified versions. If this error is
greater than some given tolerance, the linear approximation is
too coarse and we reject the new solution, shrinking the trust
region (lines 7-9). Otherwise, we accept and update the trust
region radius (lines 11-12 [3]). Moreover, in the case that
hard-penalized state constraints are not satisfied, we increase
the value of the weight ωk (line 13), pushing the solver to
seek constraint satisfaction (up to some threshold ε ≥ 0) at
the next iteration. On the other hand, when only soft trustregion constraints are satisfied, we increase the weight ωk
while maintaining the same radius ∆k (lines 15-16), pushing
the solver to look for solutions that satisfy the trust-region
constraints. The algorithm ends when successive iterations
reach an identical solution or when the state constraint weight
is greater than the maximum value ωmax.
Remark III.1. As a result of Assumptions (A1)-(A3), we
have Nk ≤ ωkC˜kxk+1 − xkkC0 , where C˜ ≥ 0 is some
constant depending only on quantities defining (OCP). Moreover, since every solution (t
k
f
, xk, uk) satisfies the initial and
final conditions for (1), it holds that 0 < dist(¯x0, Mf ) ≤
kxk+1(t
k+1
f
)−xk+1(0)k ≤ Dk. Therefore, since ωk ≤ ωmax,
it is easily seen that Algorithm 1 never becomes stuck in the
rejection step provided by lines 7-9.
No assumption on the initializing strategy (x0, u0) is
taken. From a practical point of view, this allows us to
initialize GuSTO with simple, even infeasible, guesses for
solutions of (OCP), such as a straight line in the state space.
In this case, a suitable choice of the maximal value of the
trust region radius ∆0 may be crucial to allow the method
to correctly explore the space if the provided initialization is
far from any optimal strategy. Finally, increasing the value of
weights ωk at line 3 of GuSTO eases the search for solutions
satisfying state constraints up to the ε tolerance.
B. Theoretical Convergence Guarantees
In this section, we prove that GuSTO has the property of
guaranteed convergence to an extremal solution. This result is
achieved by leveraging techniques from indirect methods in a
direct method context, which is a contribution of independent
interest discussed further in Section III-C.
The convergence of GuSTO can be inferred by adopting
one further regularity assumption concerning (LOCP)k:
(A4) At every iteration k ≥ 1 of SCP, every optimal control
uk of (LOCP)k is continuous.
We stress that although Assumption (A4) seems limiting,
many control systems in trajectory optimization applications
naturally satisfy it [23]. Moreover, the normality of Pontryagin extremals is sufficient (under minor assumptions) to
ensure that (A4) holds [24].
Thus, in view of the Pontryagin Maximum Principle [13],
our main theoretical result for SCP is the following:
Theorem III.1. Suppose that Assumptions (A1)-(A4) hold.
Given any sequence of trust region radii and weights
((∆k, ωk))k∈N ⊆ [0, ∆0] × [ω0, ωmax], let ((t
k
f
, xk, uk))k∈N
be any sequence such that for every k ≥ 1, (xk, uk) is
optimal for (LOCP)k in [0, tk
f
]. Up to some subsequence:
• t
k
f → t˜f ∈ [0, b], for the strong topology of R
• xk→ x˜ ∈ C
0
([0,t˜f ], R
n), for the strong topology of C
0
• uk → u˜ ∈ L∞([0,t˜f ], U), for the weak topology of L
2
as k tends to infinity, such that, (˜x, u˜) is feasible for (OCP) in
[0,t˜f ]. Moreover, there exists a nontrivial couple (˜p, p˜
0
) such
that the tuple (˜x, p, ˜ p˜
0
, u˜) represents a Pontryagin extremal
for (OCP) in [0,t˜f ]. In particular, as k tends to infinity, up
to some subsequence:
• (pk, p0
k
) → (˜p, p˜
0
) for the strong topology of C
0 × R
where (xk, pk, p0
k
, uk) is a Pontryagin extremal of (LOCP)k.
Finally, for fixed final time tf problems, we have t˜f = tf .
For sake of conciseness and continuity in the exposition,
we report the proof of Theorem III.1 in the Appendix. The
convergence of GuSTO to a stationary point, in the sense
of the Pontryagin Maximum Principle, for (OCP) is quickly
obtained as a corollary.
Corollary III.1. Under (A1)-(A4), in solving (OCP) by
Algorithm 1, only three mutually exclusive situations arise:
1) There exists an iteration k ≥ 1 for which ωk > ωmax.
Then, Algorithm 1 terminates, providing a solution for
(LOCP)k that does not satisfy state constraints.
2) There exists an iteration k ≥ 0 for which
(t
k+1
f
, xk+1, uk+1) = (t
k
f
, xk, uk). Then, Algorithm 1
terminates, returning a stationary point, in the sense of
the Pontryagin Maximum Principle, for (OCP).
3) We have (t
k+1
f
, xk+1, uk+1) 6= (t
k
f
, xk, uk), for every
iteration k ≥ 0. Then, Algorithm 1 builds a sequence of
optimal solutions for (LOCP)k that has a subsequence
converging (with respect to appropriate topologies) to
a stationary point, in the sense of the Pontryagin Maximum Principle, for the original problem (OCP).
Proof. Thanks to Remark III.1, it is clear that only these
three cases may happen and that they are mutually exclusive.
Then, we only need to consider cases 2) and 3). The latter
follows from Theorem III.1. If Algorithm 1 falls into case
2), then by applying the Pontryagin Maximum Principle [13]
to (LOCP)k+1, we have that (xk+1, pk+1, p0
k+1, uk+1) is the
desired (Pontryagin) stationary point for (OCP).
Case 1) of Corollary III.1 represents a failure and means
that we are not able to compute a feasible optimized strategy,
either due to an infeasible problem or an infeasible initialization that could not be refined to feasibility. The same occurs
when considering TrajOpt [1].
On the other hand, both cases 2) and 3) represent success.
However, it is important to remark that from a practical
point of view, because of numerical errors, when we begin
satisfying some convergence criterion on ((t
k
f
, xk, uk))k∈N
(which is up to the user) while solving (OCP) by GuSTO,
we usually fall into case 3) and rarely fall into case 2)
of Corollary III.1. At this point, Theorem III.1 becomes
crucial to ensuring that we are actually converging to a
stationary point, in the sense of the Pontryagin Maximum
Principle, for (OCP). This holds for the whole sequence of
solutions (t
k
f
, xk, uk), since it is itself a converging subsequence. In addition, these theoretical guarantees achieved
(a) Using controller-tracked straight-line initialization (b) Using SOS planning initialization
Fig. 2: Comparing initialization strategies on an 8D airplane model for three different SCP algorithms.
in a continuous-time setting remain valid independent of
the chosen discretization scheme, as sufficiently small time
steps allow the discrete SCP solution to remain close to the
solution of the original continuous-time problem (OCP).
Notice that a similar framework is considered in [3], in
which, for an infinite number of iterations, one can only
provide weak convergence up to some subsequence if the
control constraint set U ⊆ R
m is convex and compact. Indeed, this last assumption does not imply that L∞([0, tf ], U)
is compact (e.g., take U to be the closed unit ball [25]).
In any case, the result provided by Theorem III.1 remains
stronger because, unlike [3], we obtain strong convergence
of both trajectories and Pontryagin extremals. This feature
can be exploited to provide convergence acceleration, as
demonstrated in the next section.
C. Accelerating Convergence using Shooting Methods
An important result provided by Theorem III.1 is the
convergence of Pontryagin extremals related to the sequence
of solutions to problems (LOCP)k towards a Pontryagin extremal related to the solution of (OCP) found by GuSTO. In
particular, we can use this result to accelerate convergence by
warm-starting shooting methods [8] using the dual solution
from each SCP iteration.
This can be shown as follows. Assuming that GuSTO is
converging, the Lagrange multipliers λ
0
k
related to the initial
condition x(0) = ¯x0 for the finite dimensional discretization
of problems (LOCP)k approximate the initial values pk(0)
of the adjoint vectors related to each (LOCP)k [26]. Then,
up to some subsequence, for every small δ > 0, there exists
an iteration kδ ≥ 1 for which, for every iteration k ≥ kδ, one
has kp˜(0) − λ
0
k
k < δ, where p˜ is an adjoint vector related
to the solution of (OCP) found by SCP. This means that,
starting from some iteration k ≥ kδ, we can run a shooting
method to solve (OCP), initializing it by λ
0
k
. Thus, at each
iteration of GuSTO, we use the λ
0
k
provided by the solver to
initialize the shooting method until convergence. In practice,
this method provides a principled approach to facilitate fast
convergence of sequential convex programming towards a
more precise solution.
IV. NUMERICAL EXPERIMENTS AND DISCUSSION
In this section, we provide implementation details and
examples to demonstrate various facets of our approach.
A. Implementation Details
We implemented the examples in this section in a
trajectory optimization library written in Julia [27] and
available at https://github.com/StanfordASL/
GuSTO.jl. Computation times reported are from a Linux
system equipped with a 4.3GHz processor and 32GB RAM.
For each system and compared algorithm, we discretized the
cost and dynamics of the continuous-time optimal control
problem using a trapezoidal rule, assuming a zero-order hold
for the control. The number of discretization points N was
set to 30-40 in the presented results. We used the Bullet
Physics engine to calculate signed distance fields used for
obstacle avoidance constraints [28], [29], and an SCP trial
was marked as successful if the algorithm converged and
the resulting solution was collision-free. In comparisons with
Mao, et al. [3], since their approach does not address nonconvex state inequality constraints (e.g. collision avoidance), we
chose to enforce linearized collision-avoidance constraints in
their algorithm as hard inequality constraints.
B. Batch Comparison using a Simple Initialization Scheme
In this section, we compared the GuSTO algorithm to
previous SCP algorithms, TrajOpt [1] and Mao, et al. [3], for
a 12D free-flying spacecraft robot model, within a cluttered
mock-up of the International Space Station. For these dynamics, the state consists of position r ∈ R
3
, velocity v ∈ R
3
,
the Modified Rodrigues parameters representation of attitude
p ∈ R
3
, and angular velocity ω ∈ R
3
[30]. Constraints for
this system included norm bounds on speed, angular velocity,
and control. We modeled the free-flyer robot parameters
after the Astrobee robot [9], details of which can be found
at [31]. The dynamics discretization error reported for an
SCP solution was defined as PN−1
i=1 k(x
(i+1) − x
(i)
)N −
f(x
(i)
, u(i)
)k1. We ran 100 experiments with different start
and goal states in the environment shown in Figure 1.
Each trajectory was initialized with a simple straight line
in position space and a geodesic path in rotation space
and no control initialization. The results of our simulations
are presented in Figure 3. For the set of simulations, both
GuSTO and TrajOpt successfully returned solutions for 97%
of the trials, though GuSTO on average performed faster
and returned higher-quality solutions. Due to the simple
initialization often being deep in collision, Mao, et al. had
a high failure rate, and failure cases sometimes led to high
computation times.
C. Initialization Strategies
In practice, when a high-quality initialization trajectory
(e.g. dynamically feasible, collision-free, close to a global
optimal, etc.) is readily available, it should be used. However,
(a) Success
percentage
(b) Optimal cost (on
success)
(c) Dynamics
discretization error
(d) Success
computation times
(e) Failure
computation times
Fig. 3: Normalized simulation results for the 3D free-flying robot simulation.
an initial planner (even a coarse one) is often not available
and may be expensive to design or time-consuming to run.
Thus, we investigate the sensitivity of our approach to
initialization, including very simple initialization schemes,
again comparing with TrajOpt [1] and Mao, et al. [3].
In particular, in this section we ran simulations on an
8D airplane model, having dynamics as in [32]. To explore
different initialization strategies, we leveraged a recent approach from [33]. This approach uses a lower-dimensional
4D planning model to generate a path to the goal, which
is tracked by a controller to generate a dynamically-feasible
trajectory for the full-dimensional system. By planning with
tubes that account for model mismatch, the full 8D trajectory
is guaranteed to be collision-free.
Using this work, we tested three initialization strategies
of increasing quality for the 8D airplane: (1) a simple
straight line in the 8D state space, (2) an 8D dynamicallyfeasible (but possibly in collision) trajectory generated using
a controller to track a straight-line initialization in 4D, and
(3) an 8D dynamically-feasible and collision-free trajectory
recovered from running the full motion planning with modelmismatch tubes in 4D. As illustrated in Figure 2, the problem
scenario consists of guiding the airplane to a terminal goal
set across a cluttered environment.
For this system, due to the complex coupling in its dynamics, initialization (1) resulted in failure for all three SCP
algorithms. The results of initialization (2) can be seen in Fig.
2a, where GuSTO found a feasible solution, whereas Mao,
et. al. returned a trajectory without satisfying convergence
criteria, and TrajOpt resulted in collision. For the highestquality initialization (3), Mao, et al. did not return a solution,
whereas GuSTO and TrajOpt returned feasible trajectories,
with run times of 0.55s and 2.67s and cost improvements
over the initialization of 55% and 49%, respectively.
D. Shooting Method Acceleration
To investigate the use of dual solutions from our SCP
iterations to warm-start shooting methods and accelerate
convergence, we ran simulations on a simple 3D Dubin’s
car and the 12D free-flyer robot, where the free-flyer was
placed in an obstacle-filled environment.
The acceleration technique gave very promising results,
as shown in Table II. In practice, running a shooting method
to completion, whether to convergence or to a maximum
number of iterations, required negligible computation time
compared to an SCP iteration (< 1 ms). Thus, we attempted
a shooting method at every iteration of SCP. As shown,
using SCP to complete refinement was very time-consuming,
whereas the shooting method would converge after just a few
SCP iterations, thus reducing computation time for the car
and free-flyer models by 52% and 74%, respectively.
Dubin’s Car Free-flyer Spacecraft
Only
SCP
Shooting
SCP +
Only
SCP
Shooting
SCP +
SCP Iterations 12 6 11 3
Reported Cost 19.8 19.8 6.2 6.2
Running Time 94 ms 45 ms 570 ms 146 ms
TABLE II: Results accelerating convergence by using SCP dual
solution to warm-start a shooting method. SCP iterations report are
the number required for convergence.
E. Hardware Experiments
We also implemented GuSTO in the Stanford Space
Robotics Facility on a free-flyer robot. The robot is a threeDoF, fully holonomic system and is equipped with eight
thrusters and a reaction wheel, maneuvering on a frictionless
surface. Experiments consisted of a spacecraft navigating
a cluttered environment to berth with a capturing spacecraft. Video of the experiments can be found at https:
//youtu.be/GHehE-If5nY.
V. CONCLUSIONS
In this paper, we provided a new generalized approach
to solve trajectory optimization problems, based on sequential convex programming. We showed strong theoretical
guarantees to ensure broad applicability to many different
frameworks in motion planning and trajectory optimization.
GuSTO was tested with numerical simulations and experiments showing that more accurate solutions are achieved
faster than using recent state-of-the-art SCP solvers.
Future contributions will focus on additional theoretical
guarantees. More precisely, we will study higher-order conditions that GuSTO should naturally provide, showing its convergence to more informative points than stationary points,
as well as natural extensions of these guarantees to more
general manifolds and systems evolving in spaces having a
Lie group structure. Finally, GuSTO will be tested on highDOF systems, such as robot arms and humanoid robots, and
we will use the algorithm for hardware experiments on a
free-flyer robot in a full SE(3) microgravity environment.
ACKNOWLEDGEMENTS
We would like to thank Brian Coltin, Andrew Symington,
and Trey Smith of the Intelligent Robotics Group at NASA
Ames Research Center for their discussions during this work,
as well as Sumeet Singh, Thomas Lew, and Tariq Zahroof
for their assistance on experiment implementation.
REFERENCES
[1] J. Schulman, Y. Duan, J. Ho, A. Lee, I. Awwal, H. Bradlow, J. Pan,
S. Patil, K. Goldberg, and P. Abbeel, “Motion planning with sequential
convex optimization and convex collision checking,” Int. Journal of
Robotics Research, vol. 33, no. 9, pp. 1251–1270, 2014.
[2] X. Liu and P. Lu, “Solving nonconvex optimal control problems
by convex optimization,” AIAA Journal of Guidance, Control, and
Dynamics, vol. 37, no. 3, pp. 750 – 765, 2014.
[3] Y. Mao, M. Szmuk, and B. Ac¸ikmes¸e, “Successive convexification of
non-convex optimal control problems and its convergence properties,”
in Proc. IEEE Conf. on Decision and Control, 2016.
[4] Q. T. Dinh and M. Diehl, “Local convergence of sequential convex
programming for nonconvex optimization,” in Recent Advances in
Optimization and its Applications in Engineering. Springer, 2010.
[5] D. Verscheure, B. Demeulenaere, J. Swevers, J. De Schutter, and
M. Diehl, “Time-optimal path tracking for robots: A convex optimization approach,” IEEE Transactions on Automatic Control, vol. 54,
no. 10, pp. 2318–2327, 2009.
[6] N. Ratliff, M. Zucker, J. A. Bagnell, and S. Srinivasa, “CHOMP:
Gradient optimization techniques for efficient motion planning,” in
Proc. IEEE Conf. on Robotics and Automation, 2009.
[7] M. Kalakrishnan, S. Chitta, E. Theodorou, P. Pastor, and S. Schaal,
“STOMP: Stochastic trajectory optimization for motion planning,” in
Proc. IEEE Conf. on Robotics and Automation, 2011.
[8] J. T. Betts, “Survey of numerical methods for trajectory optimization,”
AIAA Journal of Guidance, Control, and Dynamics, vol. 21, no. 2, pp.
193–207, 1998.
[9] T. Smith, J. Barlow, M. Bualat, T. Fong, C. Provencher, H. Sanchez,
and E. Smith, “Astrobee: a new platform for free-flying robotics on
the International Space Station,” in Int. Symp. on Artificial Intelligence,
Robotics and Automation in Space, 2016.
[10] S. M. LaValle and J. J. Kuffner, “Rapidly-exploring random trees:
Progress and prospects,” in Workshop on Algorithmic Foundations of
Robotics, 2000.
[11] L. E. Kavraki, P. Svestka, J.-C. Latombe, and M. H. Overmars, ˇ
“Probabilistic roadmaps for path planning in high-dimensional spaces,”
IEEE Transactions on Robotics and Automation, vol. 12, no. 4, pp.
566–580, 1996.
[12] L. Janson, E. Schmerling, A. Clark, and M. Pavone, “Fast Marching
Tree: a fast marching sampling-based method for optimal motion
planning in many dimensions,” Int. Journal of Robotics Research,
vol. 34, no. 7, pp. 883–921, 2015.
[13] L. S. Pontryagin, Mathematical Theory of Optimal Processes. Taylor
& Francis, 1987.
[14] F. Augugliaro, A. P. Schoellig, and R. D’Andrea, “Generation of
collision-free trajectories for a quadrocopter fleet: A sequential convex
programming approach,” in IEEE/RSJ Int. Conf. on Intelligent Robots
& Systems, 2012.
[15] D. Morgan, S.-J. Chung, and F. Y. Hadaegh, “Model predictive control
of swarms of spacecraft using sequential convex programming,” AIAA
Journal of Guidance, Control, and Dynamics, vol. 37, no. 6, pp. 1725
– 1740, 2014.
[16] J. Virgili-llop, C. Zagaris, R. Zappulla II, A. Bradstreet, and M. Romano, “Convex optimization for proximity maneuvering of a spacecraft with a robotic manipulator,” in AIAA/AAS Space Flight Mechanics Meeting, 2017.
[17] C. Fleury and V. Braibant, “Structural optimization: a new dual
method using mixed variables,” Int. Journal for Numerical Methods
in Engineering, vol. 23, no. 3, pp. 409–428, 1986.
[18] S. Boyd and L. Vandenberghe, Convex optimization. Cambridge Univ.
Press, 2004.
[19] J. M. Lee, Introduction to Smooth Manifolds, 1st ed. Springer, 2003.
[20] A. F. Filippov, “On certain questions in the theory of optimal control,”
SIAM Journal on Control, vol. 1, no. 1, pp. 76–84, 1962.
[21] E. B. Lee and L. Markus, Foundations of Optimal Control Theory.
John Wiley & Sons, 1967.
[22] J. Nocedal and S. J. Wright, Numerical Optimization, 2nd ed.
Springer, 2006.
[23] Y. Chitour, F. Jean, and E. Trelat, “Singular trajectories of control- ´
affine systems,” SIAM Journal on Control and Optimization, vol. 47,
no. 2, pp. 1078–1095, 2008.
[24] I. A. Shvartsman and R. B. Vinter, “Regularity properties of optimal
controls for problems with time-varying state and control constraints,”
Nonlinear Analysis: Theory, Methods & Applications, vol. 65, no. 2,
pp. 448–474, 2006.
[25] H. Brezis, Functional Analysis, Sobolev Spaces and Partial Differential Equations, 2011.
[26] L. Gollmann, D. Kern, and H. Maurer, “Optimal control problems ¨
with delays in state and control variables subject to mixed controlstate constraints,” Optimal Control Applications and Methods, vol. 30,
no. 4, pp. 341–365, 2008.
[27] J. Bezanson, S. Karpinski, V. B. Shah, and A. Edelman. (2012) Julia:
A fast dynamic language for technical computing. Available at http:
//arxiv.org/abs/1209.5145.
[28] E. Coumans. Bullet physics. Available at http://bulletphysics.org/.
[29] C. Ericson, Real-Time Collision Detection. CRC Press, 2004.
[30] G. S. Aoude, “Two-stage path planning approach for designing ´
multiple spacecraft reconfiguration maneuvers and applications to
SPHERES onboard ISS,” Master’s thesis, Massachusetts Inst. of
Technology, 2007.
[31] Astrobee robot software. NASA. Available at https://github.com/nasa/
astrobee.
[32] R. W. Beard and T. W. McLain, Small Unmanned Aircraft: Theory
and Practice. Princeton Univ. Press, 2012.
[33] S. Singh, M. Chen, S. L. Herbert, C. J. Tomlin, and M. Pavone,
“Robust tracking with model mismatch for fast and safe planning: an
SOS optimization approach,” in Workshop on Algorithmic Foundations
of Robotics, 2018, submitted.
[34] A. A. Agrachev and Y. Sachkov, Control Theory from the Geometric
Viewpoint. Springer, 2004.
[35] T. Haberkorn and E. Trelat, “Convergence results for smooth regular- ´
izations of hybrid nonlinear optimal control problems,” SIAM Journal
on Control and Optimization, vol. 49, no. 4, pp. 1498–1522, 2011.
[36] R. Bonalli, “Optimal control of aerospace systems with control-state
constraints and delays,” Ph.D. dissertation, Sorbonne Universite &´
ONERA - The French Aerospace Lab, 2018.
[37] M. D. Shuster, “A survey of attitude representations,” Journal of the
Astronautical Sciences, vol. 41, no. 4, pp. 439 – 517, 1993.
[38] S. M. LaValle, Planning Algorithms. Cambridge Univ. Press, 2006.
APPENDIX A: PROOF OF THEOREM III.1
A. Pontryagin Maximum Principle
Our theoretical result provides convergence of SCP procedures towards a quantity satisfying first-order necessary optimality conditions under the Pontryagin Maximum Principle
[13]. Below, we report the Pontryagin Maximum Principle
for time-varying problems, which is useful hereafter.
Theorem V.1 (Pontryagin Maximum Principle). Let x be an
optimal trajectory for (OCP), associated with the control u in
[0, tf ]. There exist a nonpositive scalar p
0 and an absolutely
continuous function p : [0, tf ] → R
n, called adjoint vector,
with (p, p0
) 6= 0, and such that, almost everywhere in [0, tf ],
the following relations hold:
• Adjoint Equations



x˙(t) = ∂H
∂p (t, x(t), p(t), p0
, u(t))
p˙(t) = −
∂H
∂x (t, x(t), p(t), p0
, u(t))
(6)
• Maximality Condition
H(t, x(t), p(t), p0
, u(t)) = max
v∈U
H(t, x(t), p(t), p0
, v)
(7)
• Transversality Conditions
If Mf is a submanifold of M, locally around x(tf ),
then the adjoint vector can be built in order to satisfy
p(tf ) ⊥ Tx(tf )Mf (8)
and, in addition, if the final time tf is free, one has
max
v∈U
H(tf , x(tf ), p(tf ), p0
, v) = 0 . (9)
Here, H(t, x, p, p0
, u) = p · f(t, x, u) + p
0f
0
(t, x, u) denotes the Hamiltonian related to (OCP) and the quantity
(x, p, p0
, u) is called (Pontryagin) extremal. We say that an
extremal is normal if p
0 6= 0 and is abnormal otherwise.
It is important to remark that Theorem V.1 provides more
informative multipliers than those given by the Lagrange
multiplier rule, because control constraints do not need to be
penalized within the cost, the related Hamiltonian is globally
maximized, and (p, p0
) are merely continuous functions.
B. Pontryagin Cone Analysis
We provide the proof of Theorem III.1 for the case of
free final time problems, since, for fixed final time problems,
the proof is similar but simpler (and quite straightforward,
see below). The proof is based on the properties related
to Pontryagin cones [13]. Therefore, we start by providing
useful definitions and statements concerning these quantities.
Let x be a feasible trajectory for (OCP), with associated
control u in [0, tf ]. Throughout the proof, we assume that
tf is a Lebesgue point of u. Otherwise, one proceeds using
limiting cones as done in [21]. For every Lebesgue point
s ∈ [0, tf ] of u and every v ∈ U, we define local variations
as
ψ
s,v
x,u =

f(x(s), v) − f(x(s), u(s))
f
0
(x(s), v) − f
0
(x(s), u(s)) 
. (10)
The variation vector w
s,v
x,u : [0, tf ] → R
n+1 for (OCP) is the
solution of the following variational system



ψ˙(t) = ψ(t)


∂f
∂x(x(t), u(t))
∂f 0
∂x (x(t), u(t))


ψ(s) = ψ
s,v
x,u
. (11)
At this step, for every t ∈ [0, tf ], we define the Pontryagin
cone Kx,u(t) at t for (x, u) related to (OCP) to be the
smallest closed convex cone containing w
s,v
x,u(t) for every
0 < s < t Lebesgue point of u and every v ∈ U. Arguing by
contradiction [34], [35], the Pontryagin Maximum Principle
states that, if (tf , x, u) is optimal for (OCP), then there exists
a nontrivial couple (pf , p0
) ∈ R
n+1 satisfying



pf ⊥ Tx(tf )Mf , p0 ≤ 0
(pf , p0
) · w ≤ 0 , ∀ w ∈ Kx,u(tf )
max
v∈U
H(x(tf ), pf , p0
, v) = 0
. (12)
Relations (6)-(9) derive from (12). In particular, a tuple
(x, p, p0
, u) is a Pontryagin extremal for (OCP) iff the nontrivial couple (p(tf ), p0
) ∈ R
n+1 satisfies (12). However, a
Pontryagin extremal is not necessarily a solution for (OCP).
Now, consider controls uk and uk+1, solutions of
(LOCP)k and of (LOCP)k+1 with final times t
k
f
and t
k+1
f
,
respectively. If necessary and without loss of generality,
thanks to Assumption (A3) we can continuously extend these
controls to be constant in [t
k
f
, b] and [t
k+1
f
, b], respectively.
We apply the same procedure to trajectories xk and xk+1.
Therefore, for every iteration k ≥ 1, uk, uk+1 are continuous
functions in [0, b] and for every s ∈ [0, b] and every v ∈ U,
we are able to define local variations for (LOCP)k+1 as
ψ
s,v
k+1 =

fk+1(s, xk+1(s), v) − fk+1(s, xk+1(s), uk+1(s))
f
0
k+1(s, xk+1(s), v) − f
0
k+1(s, xk+1(s), uk+1(s)) 
(13)
and related variation vectors w
s,v
k+1 : [0, b] → R
n+1 as the
solutions of the following variational system:



ψ˙(t) = ψ(t)


∂fk+1
∂x (t, xk+1(t), uk+1(t))
∂f 0
k+1
∂x (t, xk+1(t), uk+1(t))


ψ(s) = ψ
s,v
k+1
. (14)
Thus, from the above and due to the optimality of
(t
k+1
f
, xk+1, uk+1), the Pontryagin Maximum Principle
states that, for every iteration k of SCP, there exists a nontrivial couple (pk+1, p0
k+1) ∈ C
0
([0, b], R
n) × R satisfying



pk+1(t
k+1
f
) ⊥ Txk+1(t
k+1
f
)Mf , p0
k+1 ≤ 0
(pk+1(t
k+1
f
), p0
k+1) · w ≤ 0 , ∀ w ∈ Kk+1(t
k+1
f
)
max
v∈U
Hk+1(t
k+1
f
, xk+1(t
k+1
f
), pk+1(t
k+1
f
), p0
k+1, v) = 0
(15)
where the Pontryagin cone Kk+1(t) at t for (LOCP)k+1
is defined as above, by substituting (10)-(11) with (13)-(14),
and Hk+1 is the Hamiltonian related to problem (LOCP)k+1.
We now prove Theorem III.1 in two main steps:
1) Convergence of Trajectories and Controls: First, consider the sequence of final times (t
k
f
)k∈N. Thanks to Assumption (A3), there exists t˜f ∈ [0, b] such that, up to
some subsequence, (t
k
f
)k∈N converges to t˜f . As discussed
previously, from now on, we consider every couple (xk, uk)
to be continuously defined in the time interval [0, b].
Next, consider the sequence (uk)k∈N ⊆ L∞([0, b], U).
Thanks to Assumption (A1), (uk)k∈N is bounded in
L
2
([0, b], R
m). Moreover, the subset L
2
([0, b], U) is closed
and convex in L
2
([0, b], R
m) for the strong topology, and
then also for the weak topology [25]. Thanks to Assumption
(A1) and reflexive properties for L
2
, there exists u˜ ∈
L∞([0, b], U) such that, up to some subsequence, (uk)k∈N
converges to u˜ for the weak topology of L
2
[25].
Finally, we focus on the sequence (xk)k∈N ⊆
C
0
([0, b], R
n). It is clear that Assumptions (A1) and (A2)
provide that both (xk)k∈N and ( ˙xk)k∈N are bounded in
L
2
([0, b], R
n). Therefore, (xk)k∈N is bounded in the Sobolev
space H1
([0, b], R
n). From reflexive properties, it follows
that there exists x˜ ∈ H1
([0, b], R
n) such that, up to some
subsequence, (xk)k∈N converges to x˜ for the weak topology
of H1
. Furthermore, since the inclusion H1
,−→ C
0
is
compact, (xk)k∈N converges to x˜ ∈ C
0
([0, b], R
n) for the
strong topology of C
0
[25]
For every integer k, (xk+1, uk+1) is feasible for
(LOCP)k+1, and therefore (after the obvious extensions),
xk+1(t) = ¯x0+
Z t
0
fk+1(s, xk+1(s), uk+1(s)) ds , t ∈ [0, b].
From this, by exploiting Assumptions (A1), (A2), and the
previous convergences, it follows that (˜x, u˜) is feasible for
problem (OCP) (note that x˜(t˜f ) = lim
k→∞
xk(t
k
f
) ∈ Mf , since,
up to some subsequence, the limit lim
k→∞
xk(t
k
f
) exists thanks
to the compactness of Mf , see Assumption (A1)).
2) Convergence of Multipliers: We now discuss the convergence to a Pontryagin extremal for (OCP). Assumption
(A4) proves crucial to establishing the following Lemma:
Lemma V.1. Suppose that Assumption (A4) holds. For every
s ∈ (0,t˜f ) Lebesgue point of u˜, there exists a sequence
(sk)k∈N ⊆ [s,t˜f ), for which sk is a Lebesgue point of uk
and of uk+1, such that
uk(sk) → u˜(s) , uk+1(sk) → u˜(s) , sk → s
as k tends to infinity.
Proof. We denote
hk(t) = (uk(t), uk+1(t)) , h(t) = (u(t), u(t)).
Let us prove that, for every s ∈ (0,t˜f ) Lebesgue point of
h(·) and for every β > 0, αs > 0 (such that s + αs < t˜f ),
there exists γs,αs,β > 0 such that, for every k ∈ N satisfying
1/k ∈ (0, γs,αs,β), there exists a sk ∈ [s, s + αs] Lebesgue
point of hk(·) for which khk(sk) − h(s)k < β.
By contradiction, suppose that there exists s ∈ (0,t˜f ), a
Lebesgue point of h(·), and β > 0, αs > 0 (with s+αs < t˜f )
such that, for every γ > 0, there exists k ∈ N with 1/k ∈
(0, γ) and ik ∈ {1, . . . , m} for which, for t ∈ [s, s + αs]
Lebesgue point of hk(·), it holds that |h
ik
k
(t) − h
ik (s)| ≥ β.
From the previous convergence results, the family
(hk(·))k∈N converges to h(·) in L
2
for the weak topology.
Therefore, for every 0 < δ ≤ 1, there exists an integer kδ
such that, for every k ≥ kδ, it holds that
1
δαs



Z s+δαs
s
h
i
k
(t) dt −
Z s+δαs
s
h
i
(t) dt


 <
β
3
for every i ∈ {1, . . . , m}. We exploit this fact to bound
|h
ik
k
(t) − h
ik (s)| by β. First, since s is a Lebesgue point of
h(·), there exists 0 < δs,αs ≤ 1 such that



h
i
(s) −
1
δs,αs αs
Z s+δs,αsαs
s
h
i
(t) dt


 <
β
3
for every i ∈ {1, . . . , m}. On the other hand, from what was
said previously, there exists an integer kδs,αs
such that
1
δs,αs αs



Z s+δs,αsαs
s
h
i
k
(t) dt −
Z s+δs,αsαs
s
h
i
(t) dt


 <
β
3
for every k ≥ kδs,αs
and every i ∈ {1, . . . , m}. Finally, by
Assumption (A4), we have that hk(·) is continuous for k ∈
N, and then, for every k ≥ kδs,αs
and every i ∈ {1, . . . , m},
there exists tk,i ∈ [s, s + δs,αs αs] ⊆ [s, s + αs] such that



h
i
k
(tk,i) −
1
δs,αs αs
Z s+δs,αsαs
s
h
i
k
(t) dt


 <
β
3
.
Resuming, for every k ≥ kδs,αs
and i ∈ {1, . . . , m} there
exists a tk,i ∈ [s, s + αs] Lebesgue point of hk(·) (by continuity) such that |h
i
k
(tk,i) − h
i
(s)| < β, a contradiction.
Lemma V.1 represents the main tool to prove the convergence of Pontryagin cones, provided by the following lemma:
Lemma V.2. For every w ∈ Kx, ˜ u˜(t˜f ), k ∈ N, there exists
wk ∈ Kk(t
k
f
) such that wk → w as k tends to infinity.
Proof. Without loss of generality, we may assume that w =
w
s,v
x, ˜ u˜
(t˜f ), where v ∈ U and 0 < s < t˜f is a Lebesgue point
of u˜ (see [36, Lemma 7.8] for technical details).
From Lemma V.1, there exists a family (sk)k∈N ⊆ [s,t˜f ),
which are Lebesgue points of uk and of uk+1, such that
uk(sk) → u˜(s) , uk+1(sk) → u˜(s) , sk → s
as soon as k tends to infinity. This allows us to consider
w
sk,v
k+1 , solutions of system (14) with initial state given by
(13) at sk.
From the previous convergences, it is clear that (ψ
sk,v
k+1 )k∈N
converges to ψ
s,v
x, ˜ u˜ = w
s,v
x, ˜ u˜
(s) as soon as k tends to infinity.
Moreover, since (∆k, ωk)k∈N ⊆ [0, ∆0] × [ω0, ωmax] is
bounded, we have that up to some subsequence, it converges
to some point (∆˜ , ω˜) ∈ [0, ∆0]×[ω0, ωmax] satisfying either
∆ = 0 ˜ or ∆˜ > 0. In both cases, again from the previous
convergences, the dynamics of system (14) converge to the
dynamics of system (11) for the weak topology of L
2
.
Summing up, by the continuous dependence w.r.t. initial
state and weakly w.r.t. controls for dynamical systems ,
the sequence (wk+1)k∈N = (w
sk,v
k+1 (t
k
f
))k∈N satisfies wk ∈
Kk(t
k
f
) and converges to w as k tends to infinity.
We are now able to conclude the proof of Theorem III.1.
For every integer k ≥ 1, consider the nontrivial couple
(pk, p0
k
) ∈ C
0
([0, tk
f
], R
n) × R, provided by Theorem V.1,
related to some optimal solution (t
k
f
, xk, uk) for (LOCP)k.
In particular, (pk(t
k
f
), p0
k
) 6= 0. Therefore, up to normalization, we can assume that k(pk(t
k
f
), p0
k
)k = 1, for every
k ∈ N \ {0}. We infer that, up to some subsequence, there
exists a point (˜pf , p˜
0
) ∈ S
n (in particular, (˜pf , p˜
0
) 6= 0)
satisfying (pk(t
k
f
), p0
k
) → (˜pf , p˜
0
) as k tends to infinity.
Now, take any w ∈ Kx, ˜ u˜(t˜f ). Thanks to Lemma V.2, there
exists a sequence (wk)k∈N, such that wk ∈ Kk(t
k
f
), which
converges to w as soon as k tends to infinity. By continuity,
from (15) it follows that p˜f ⊥ Tx˜(t˜f )Mf and (˜pf , p˜
0
)·w ≤ 0.
Moreover, since ((∆k, ωk))k∈N ⊆ [0, ∆0] × [ω0, ωmax] is
bounded, up to some subsequence, it converges to some point
(∆˜ , ω˜) ∈ [0, ∆0] × [ω0, ωmax] satisfying either ∆ = 0 ˜ or
∆˜ > 0. In both cases, it is not difficult to prove that
lim
k→∞
|H(˜x(t˜f ), p˜(t˜f ), p˜
0
, v)−Hk(t
k
f
, xk(t
f
k
), pk(t
k
f
), p0
k
, v)| = 0
uniformly with respect to v ∈ U. Therefore, since w ∈
Kx, ˜ u˜(tf ) is arbitrary, (˜pf , p˜
0
) satisfies relations (12) for
(x, u) = (˜x, u˜), and then, denoting by p˜ the solution of



p˙(t) = −(p(t), p˜
0
)


∂f
∂x(˜x(t), u˜(t))
∂f 0
∂x (˜x(t), u˜(t))


p(tf ) = ˜pf
the quantity (˜x, p, ˜ p˜
0
, u˜) represents a Pontryagin extremal
for problem (OCP). In particular, thanks to the previous
convergences and the continuous dependence w.r.t. initial
state and weakly w.r.t. controls for dynamical systems, we
have that up to some subsequence, (pk)k∈N converges to p˜
for the strong topology of C
0
, as k → ∞.
This concludes the proof of Theorem III.1.
Remark V.1. In formulations (LOCP)k, we linearize the
terms depending on the state. However, in the case that
convex functions of the state appear within the cost, both
our numerical scheme and our theoretical result still hold
even if these convex terms are not linearized (the proof of
this fact exactly retraces the proof of our convergence result).
APPENDIX B: ADDITIONAL EXPERIMENTAL DETAILS
A. Free-Flying Spacecraft Robot Model
The 12D state for the free-flying spacecraft robot model
consists of position r ∈ R
3
, velocity v ∈ R
3
, the Modified
Rodrigues parameters representation of attitude p ∈ R
3
, and
angular velocity ω ∈ R
3
[30], [37], and the control variables
are the force F ∈ R
3
and moment M ∈ R
3
. The continuoustime dynamics are given by


r˙
v˙
p˙
ω˙

 =


v
F/m
1
4
((1 − |p|
2
)ω − 2ω × p + 2(ω · p)p)
J
−1
(M − ω × Jω)


where m and J are the robot mass and inertia tensor,
respectively. State constraints for this system include norm
bounds for velocity and angular velocity, as well as norm
bound control constraints for the force and moment.
B. Airplane Model
The state for the 8D airplane model consists of the position
x, y, z, course angle ψ, airspeed v, flight path angle γ,
roll angle φ, and angle-of-attack α [32]. The control inputs
consist of longitudinal acceleration ua, roll rate uφ˙
, and pitch
rate uα˙
. The continuous-time dynamics are given by


x˙
y˙
z˙
ψ˙
v˙
γ˙
φ˙
α˙


=


v cos ψ cos γ
v sin ψ cos γ
v sin γ
−Flift(v, α) sin φ/(mv cos γ)
ua − Fdrag(v, α)/m − g sin γ
Flift(v, α) cos φ/(mv) − g cos γ/v
uφ˙
uα˙


where m is the airplane mass and g is gravitational acceleration. A flat-plate airfoil model is used for calculating the lift
force Flift(v, α) = πρAv2α and drag force Fdrag(v, α) =
ρAv2
(CD0 + 4πKα2
), for air density ρ, wing area A, drag
coefficient CD0
, and the induced drag factor K. Constraints
for this system consist of box constraints on states ψ, v, γ,
and φ, as well as on controls ua, uφ˙
, and uα˙
.
C. Dubins Car Model
The Dubin’s car model used is a simple three-dimensional
kinematic model consisting of positions x and y, orientation
θ, and steering control u [38]. The continuous-time dynamics
are given by:


x˙
y˙
˙θ

 =

v cos θ
v sin θ
ku !
where v is the constant speed of the car and k is a curvature
constant.